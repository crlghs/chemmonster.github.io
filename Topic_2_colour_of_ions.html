<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ion Colour Challenge: Match the Aqueous Ions!</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<style>
    /* Root variables for consistent theming */
    :root {
        --sky-top: #87CEEB; /* Light blue */
        --sky-bottom: #d1e9f3; /* Lighter blue */
        --ion-falling-color: #FFFFFF; /* Bright white for ion text */
        --text-dark: #333; /* Dark text for readability */
        --beaker-border: #555; /* Darker border for beakers */
        --button-bg: #4CAF50; /* Green button */
        --button-hover-bg: #45a049; /* Darker green on hover */
        --overlay-bg: rgba(0, 0, 0, 0.7); /* Semi-transparent black for overlays */
        --correct-feedback: gold; /* Gold for correct feedback */
        --wrong-feedback: rgba(255, 0, 0, 0.7); /* Red for wrong feedback */
        --score-color: #007bff; /* Blue for score */
        --lives-color: #dc3545; /* Red for lives */
        --timer-color: #ffc107; /* Orange for timer */
    }

    body {
        font-family: 'Poppins', sans-serif;
        text-align: center;
        margin: 0;
        overflow: hidden; /* Prevent scrollbars */
        background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom));
        color: var(--text-dark);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        min-height: 100vh; /* Ensure body takes full viewport height */
    }

    #game-container {
        position: relative;
        width: 100vw; /* Full viewport width */
        height: 100vh; /* Maximized falling area to 100% of viewport height */
        max-width: 1200px; /* Max width for desktop */
        margin: 0 auto;
        overflow: hidden;
        border-radius: 1rem; /* Rounded corners */
        box-shadow: 0 0.5rem 1.5rem rgba(0, 0, 0, 0.2);
        background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom));
        display: flex;
        flex-direction: column;
        justify-content: flex-end; /* Push beakers to the bottom */
    }

    /* Score, Lives, and Timer Display */
    #game-info {
        position: absolute;
        top: 1rem;
        left: 1rem;
        display: flex;
        flex-direction: column; /* Stack vertically */
        gap: 0.5rem; /* Space between info lines */
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--text-dark);
        background-color: rgba(255, 255, 255, 0.7);
        padding: 0.5rem 1rem;
        border-radius: 0.8rem;
        box-shadow: 0 0.2rem 0.5rem rgba(0, 0, 0, 0.1);
        z-index: 10; /* Ensure it's above other elements */
        align-items: flex-start; /* Align text to the left */
    }

    #game-info span {
        display: flex;
        align-items: center;
        width: 100%; /* Ensure spans take full width for alignment */
    }

    #game-info .score-value {
        color: var(--score-color);
        margin-left: 0.3rem;
    }

    #game-info .lives-value {
        color: var(--lives-color);
        margin-left: 0.3rem;
    }

    #game-info .timer-value {
        color: var(--timer-color);
        margin-left: 0.3rem;
    }

    /* Falling Ions */
    .ion {
        position: absolute;
        font-size: 1.8rem; /* Larger font for ions */
        font-weight: 700;
        color: var(--ion-falling-color);
        text-shadow: 0 0 0.5rem rgba(0, 0, 0, 0.5);
        user-select: none;
        pointer-events: none; /* Ions don't block clicks */
        z-index: 5;
        animation: pulse 1s infinite alternate; /* Subtle pulse animation */
    }

    @keyframes pulse {
        from { transform: scale(1); opacity: 1; }
        to { transform: scale(1.05); opacity: 0.9; }
    }

    /* Beakers */
    .beaker {
        position: absolute; /* Changed to absolute for independent dragging */
        width: 6rem; /* Reduced size */
        height: 5rem; /* Reduced size */
        background-color: #f0f0f0; /* Default beaker color */
        border: 0.2rem solid var(--beaker-border);
        border-radius: 0.4rem 0.4rem 1.5rem 1.5rem; /* Adjusted border-radius */
        cursor: grab;
        display: flex;
        flex-direction: column;
        justify-content: flex-end; /* Push label to bottom */
        align-items: center;
        box-shadow: 0 0.4rem 0.8rem rgba(0, 0, 0, 0.2);
        transition: transform 0.1s ease-out; /* Smooth movement */
        user-select: none; /* Prevent text selection */
        z-index: 10; /* Ensure beakers are on top */
    }

    .beaker:active {
        cursor: grabbing;
        transform: scale(0.98); /* Slight squash effect when grabbed */
    }

    .beaker-label {
        font-size: 0.8rem; /* Adjusted font size for smaller beaker */
        font-weight: 600;
        color: var(--text-dark);
        margin-bottom: 0.3rem; /* Adjusted margin */
        text-shadow: 0 0 0.2rem rgba(255, 255, 255, 0.5);
    }

    /* Specific Beaker Colors */
    .beaker[data-color="blue"] { background-color: #6495ED; } /* Cornflower Blue */
    .beaker[data-color="yellow/brown"] { background-color: #FFD700; } /* Gold */
    .beaker[data-color="pale green"] { background-color: #98FB98; } /* Pale Green */
    .beaker[data-color="purple"] { background-color: #8A2BE2; } /* Blue Violet */
    .beaker[data-color="orange"] { background-color: #FFA500; } /* Orange */
    /* .beaker[data-color="pink"] { background-color: #FF69B4; } Removed pink beaker */
    .beaker[data-color="colourless"] { background-color: #F8F8F8; border: 0.2rem dashed var(--beaker-border); } /* Very light grey, dashed border */
    .beaker[data-color="green"] { background-color: #3CB371; } /* Medium Sea Green */


    /* Feedback messages */
    .feedback-message {
        position: absolute;
        font-size: 2.5rem;
        font-weight: 700;
        color: white;
        text-shadow: 0 0 1rem rgba(0, 0, 0, 0.8);
        animation: fadeOutUp 1s forwards;
        z-index: 20;
        pointer-events: none;
    }

    @keyframes fadeOutUp {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-5rem); }
    }

    /* Feedback particles */
    .feedback-particle {
        position: absolute;
        border-radius: 50%;
        opacity: 0;
        animation: explode 0.6s forwards;
        z-index: 15;
    }

    @keyframes explode {
        from { transform: translate(0, 0) scale(1); opacity: 1; }
        to { transform: translate(var(--end-x), var(--end-y)) scale(0); opacity: 0; }
    }

    /* Overlays (Instructions, Game Over) */
    .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        z-index: 100; /* Highest z-index */
        padding: 2rem;
        box-sizing: border-box;
    }

    .overlay-content {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 3rem;
        border-radius: 1.5rem;
        box-shadow: 0 0.5rem 2rem rgba(0, 0, 0, 0.3);
        max-width: 90%;
        color: var(--text-dark);
        text-align: center;
        max-height: 90vh; /* Limit height for scrollable content */
        overflow-y: auto; /* Enable scrolling for long content */
    }

    .overlay-content h2 {
        font-size: 2.5rem;
        margin-bottom: 1.5rem;
        color: #0056b3; /* Darker blue for headings */
    }

    .overlay-content p {
        font-size: 1.2rem;
        line-height: 1.6;
        margin-bottom: 2rem;
    }

    .overlay-content button {
        background-color: var(--button-bg);
        color: white;
        border: none;
        padding: 1rem 2rem;
        font-size: 1.4rem;
        font-weight: 600;
        border-radius: 0.8rem;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.1s ease;
        box-shadow: 0 0.3rem 0.6rem rgba(0, 0, 0, 0.2);
        margin-top: 1.5rem; /* Added margin to separate from text */
        margin-bottom: 2rem; /* Added margin to separate from table */
    }

    .overlay-content button:hover {
        background-color: var(--button-hover-bg);
        transform: translateY(-0.1rem);
    }

    .overlay-content button:active {
        transform: translateY(0);
        box-shadow: 0 0.1rem 0.3rem rgba(0, 0, 0, 0.2);
    }

    /* Reference Table Container */
    .ion-table-container {
        margin-top: 2rem;
        text-align: left;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: inset 0 0 0.5rem rgba(0, 0, 0, 0.1);
    }

    .ion-table-container h3 {
        font-size: 1.8rem;
        color: #0056b3;
        margin-bottom: 1rem;
        text-align: center;
    }

    .ion-table-container table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
    }

    .ion-table-container th, .ion-table-container td {
        border: 1px solid #ddd;
        padding: 0.8rem;
        text-align: left;
        font-size: 1rem;
    }

    .ion-table-container th {
        background-color: #f2f2f2;
        font-weight: 600;
    }

    .ion-table-container tr:nth-child(even) {
        background-color: #f9f9f9;
    }

    /* Confetti particles */
    .confetti-particle {
        position: absolute;
        border-radius: 50%; /* Make them round */
        opacity: 0; /* Start invisible */
        transform: translateY(0) rotate(0deg); /* Initial state for animation */
        z-index: 101; /* Above the overlay content */
    }

    @keyframes confetti-fall {
        0% {
            opacity: 1;
            transform: translate(0, 0) rotate(0deg);
        }
        100% {
            opacity: 0;
            transform: translate(var(--confetti-end-x-offset), var(--confetti-end-y)) rotate(var(--confetti-rotation));
        }
    }

    /* Responsive Design - Media Queries */

    /* Mobile devices (portrait) */
    @media (max-width: 767px) {
        #game-container {
            height: 100vh; /* Full height on mobile */
        }

        #game-info {
            font-size: 1rem;
            padding: 0.4rem 0.8rem;
            top: 0.5rem;
            left: 0.5rem;
            gap: 0.3rem;
        }

        .ion {
            font-size: 1.5rem;
        }

        /* Beaker adjustments for mobile */
        .beaker {
            width: 5rem; /* Further reduced for mobile */
            height: 4rem;
            border-radius: 0.3rem 0.3rem 1rem 1rem;
        }

        .beaker-label {
            font-size: 0.6rem;
            margin-bottom: 0.2rem;
        }

        .feedback-message {
            font-size: 1.8rem;
        }

        .overlay-content {
            padding: 1.5rem;
        }

        .overlay-content h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .overlay-content p {
            font-size: 1rem;
            margin-bottom: 1.5rem;
        }

        .overlay-content button {
            padding: 0.8rem 1.5rem;
            font-size: 1.2rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
        }

        .ion-table-container {
            max-height: 30vh; /* Adjust height for table on mobile */
        }

        .ion-table-container h3 {
            font-size: 1.5rem;
        }

        .ion-table-container th, .ion-table-container td {
            padding: 0.6rem;
            font-size: 0.9rem;
        }
    }

    /* Tablet devices (portrait and landscape) */
    @media (min-width: 768px) and (max-width: 1199px) {
        #game-container {
            height: 100vh; /* Full height on tablet */
        }

        #game-info {
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
        }

        .ion {
            font-size: 1.6rem;
        }

        /* Beaker adjustments for tablet */
        .beaker {
            width: 7rem;
            height: 6rem;
            border-radius: 0.4rem 0.4rem 1.8rem 1.8rem;
        }

        .beaker-label {
            font-size: 0.9rem;
        }

        .feedback-message {
            font-size: 2rem;
        }

        .overlay-content {
            padding: 2rem;
        }

        .overlay-content h2 {
            font-size: 2.2rem;
        }

        .overlay-content p {
            font-size: 1.1rem;
        }

        .overlay-content button {
            padding: 0.9rem 1.8rem;
            font-size: 1.3rem;
            margin-top: 1.2rem;
            margin-bottom: 1.8rem;
        }

        .ion-table-container {
            max-height: 35vh; /* Adjust height for table on tablet */
        }

        .ion-table-container h3 {
            font-size: 1.6rem;
        }
    }
</style>
</head>
<body>

<div id="game-container">
    <div id="game-info">
        <span>Score: <span id="score-value">0</span></span>
        <span>Lives: <span id="lives-value">3</span></span>
        <span>Time: <span id="timer-value">60s</span></span>
    </div>

    <!-- Beakers will be dynamically generated here by JS -->

    <!-- Instructions Overlay -->
    <div id="instructions-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Welcome to the Ion Colour Challenge!</h2>
            <p>Test your knowledge of aqueous ion colors in this fun and interactive game. Ions will fall from the top of the screen, and your goal is to drag the correct colored beaker to catch them. Match the ion to its characteristic color in aqueous solution!</p>
            <p>Correct matches earn points, while incorrect matches or missed ions will cost you a life. Pay attention to the colors, and good luck!</p>

            <button id="start-game-button">Start Game</button>

            <div class="ion-table-container">
                <h3>Aqueous Ion Colours Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Ion Formula</th>
                            <th>Common Name</th>
                            <th>Colour</th>
                        </tr>
                    </thead>
                    <tbody id="instructions-ions-table-body">
                        <!-- Ion data will be populated here by JS -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div class="overlay-content">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Percentage Score: <span id="percentage-score">0%</span></p>
            <p id="performance-comment"></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
</div>

<script>
    // Game state variables
    let score = 0;
    let lives = 3;
    let gameSpeed = 1; // Pixels per frame
    let ionInterval = 2000; // Milliseconds between new ions
    let gameRunning = false;
    let lastIonTime = 0;
    let animationFrameId;
    let gameDuration = 60; // seconds
    let timeLeft = gameDuration;
    let timerIntervalId;
    let totalIonsSpawned = 0; // Track total ions spawned for percentage calculation

    // DOM elements
    const gameContainer = document.getElementById('game-container');
    const scoreValueSpan = document.getElementById('score-value');
    const livesValueSpan = document.getElementById('lives-value');
    const timerValueSpan = document.getElementById('timer-value'); // New timer element
    const instructionsOverlay = document.getElementById('instructions-overlay');
    const startGameButton = document.getElementById('start-game-button');
    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoreSpan = document.getElementById('final-score');
    const percentageScoreSpan = document.getElementById('percentage-score'); // New percentage score element
    const performanceCommentP = document.getElementById('performance-comment'); // New performance comment element
    const playAgainButton = document.getElementById('play-again-button');
    const instructionsIonsTableBody = document.getElementById('instructions-ions-table-body'); // For instructions table

    // Get CSS custom properties for feedback colors
    const rootStyles = getComputedStyle(document.documentElement);
    const correctFeedbackColor = rootStyles.getPropertyValue('--correct-feedback').trim();
    const wrongFeedbackColor = rootStyles.getPropertyValue('--wrong-feedback').trim();

    // Sound Effects using Tone.js
    let correctSynth;
    let wrongSynth;

    // Initialize Tone.js synths
    function initializeAudio() {
        // Correct sound: simple sine wave, higher pitch
        correctSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.005,
                decay: 0.1,
                sustain: 0.05,
                release: 0.2
            }
        }).toDestination();

        // Wrong sound: simple square wave, lower pitch, slightly longer decay
        wrongSynth = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: {
                attack: 0.005,
                decay: 0.2,
                sustain: 0.1,
                release: 0.3
            }
        }).toDestination();
    }

    // Play correct sound
    function playCorrectSound() {
        if (correctSynth) {
            correctSynth.triggerAttackRelease("C5", "8n"); // C5 for 8th note
        }
    }

    // Play wrong sound
    function playWrongSound() {
        if (wrongSynth) {
            wrongSynth.triggerAttackRelease("C3", "8n"); // C3 for 8th note
        }
    }

    // Define aqueous ions and their properties
    // Each ion has a name (formula), commonName, and characteristic color
    const aqueousIons = [
        { name: 'Cu²⁺', commonName: 'Copper(II) Ion', color: 'blue' },
        { name: 'Fe³⁺', commonName: 'Iron(III) Ion', color: 'yellow/brown' },
        { name: 'Fe²⁺', commonName: 'Iron(II) Ion', color: 'green' },
        { name: 'MnO₄⁻', commonName: 'Permanganate Ion', color: 'purple' },
        { name: 'Cr₂O₇²⁻', commonName: 'Dichromate Ion', color: 'orange' },
        { name: 'Ni²⁺', commonName: 'Nickel(II) Ion', color: 'green' },
        { name: 'Cr³⁺', commonName: 'Chromium(III) Ion', color: 'green' },
        // Added new colourless ions
        { name: 'K⁺', commonName: 'Potassium Ion', color: 'colourless' },
        { name: 'Na⁺', commonName: 'Sodium Ion', color: 'colourless' },
        { name: 'Li⁺', commonName: 'Lithium Ion', color: 'colourless' },
        { name: 'Ca²⁺', commonName: 'Calcium Ion', color: 'colourless' },
        { name: 'Mg²⁺', commonName: 'Magnesium Ion', color: 'colourless' },
        { name: 'Al³⁺', commonName: 'Aluminium Ion', color: 'colourless' },
        { name: 'SO₄²⁻', commonName: 'Sulfate Ion', color: 'colourless' },
        { name: 'Cl⁻', commonName: 'Chloride Ion', color: 'colourless' },
        { name: 'NH₄⁺', commonName: 'Ammonium Ion', color: 'colourless' },
        { name: 'CO₃²⁻', commonName: 'Carbonate Ion', color: 'colourless' },
        { name: 'NO₃⁻', commonName: 'Nitrate Ion', color: 'colourless' },
        { name: 'OH⁻', commonName: 'Hydroxide Ion', color: 'colourless' },
        { name: 'Mn²⁺', commonName: 'Manganese(II) Ion', color: 'colourless' }, // Added as colourless
    ];

    // Filter ions into colored and colorless categories
    const colouredIons = aqueousIons.filter(ion => ion.color !== 'colourless');
    const colourlessIons = aqueousIons.filter(ion => ion.color === 'colourless');

    // Probability of selecting a colored ion (e.g., 70%)
    const colouredIonProbability = 0.7;

    // Beaker configurations based on ion colors
    const beakerConfigs = [
        { label: 'Blue Ions', color: 'blue' },
        { label: 'Yellow/Brown Ions', color: 'yellow/brown' },
        { label: 'Green Ions', color: 'green' },
        { label: 'Purple Ions', color: 'purple' },
        { label: 'Orange Ions', color: 'orange' },
        { label: 'Colourless Ions', color: 'colourless' },
    ];

    // Store beaker elements for drag functionality
    let beakers = [];

    // --- Game Initialization and Setup ---

    function initializeGame() {
        score = 0;
        lives = 3;
        gameSpeed = 1;
        ionInterval = 2000;
        gameRunning = false;
        lastIonTime = 0;
        totalIonsSpawned = 0; // Reset total ions spawned
        timeLeft = gameDuration; // Reset timer
        updateScoreLives();
        clearIons();
        // Clear any existing timer interval
        if (timerIntervalId) {
            clearInterval(timerIntervalId);
        }
        // Clear all existing beakers from the game container
        document.querySelectorAll('.beaker').forEach(beaker => beaker.remove());
        createBeakers();
        populateInstructionsTable(); // Populate the table in the instructions overlay
        gameOverOverlay.style.display = 'none';
        instructionsOverlay.style.display = 'flex'; // Show instructions initially
        // Ensure audio context is ready when game starts
        if (Tone.context.state !== 'running') {
            Tone.start();
        }
    }

    function createBeakers() {
        beakers = []; // Reset beakers array
        // Get actual computed width of a beaker to ensure accurate spacing
        // Temporarily create a dummy beaker to measure its width
        const dummyBeaker = document.createElement('div');
        dummyBeaker.className = 'beaker';
        dummyBeaker.style.visibility = 'hidden'; // Hide it
        gameContainer.appendChild(dummyBeaker);
        const beakerWidthPx = dummyBeaker.offsetWidth;
        dummyBeaker.remove(); // Remove the dummy beaker

        const gap = 20; // Gap between beakers
        const beakersPerRow = 3; // Number of beakers per row
        const rowHeight = 70; // Approximate height for each row of beakers

        // Calculate total width needed for beakers in a row
        const rowTotalWidth = beakersPerRow * beakerWidthPx + (beakersPerRow - 1) * gap;
        // Calculate startX to center each row of beakers
        const startX = (gameContainer.clientWidth - rowTotalWidth) / 2;

        beakerConfigs.forEach((config, index) => {
            const beakerDiv = document.createElement('div');
            beakerDiv.className = 'beaker';
            beakerDiv.setAttribute('data-color', config.color);

            // Determine row and column for positioning
            const row = Math.floor(index / beakersPerRow);
            const col = index % beakersPerRow;

            const initialLeft = startX + col * (beakerWidthPx + gap);
            let initialBottom;

            // Position based on row
            if (row === 0) {
                // Bottom row
                initialBottom = '2rem';
            } else {
                // Top row (above the bottom row)
                initialBottom = `${2 * parseFloat(getComputedStyle(document.documentElement).fontSize) + rowHeight + 20}px`; // 2rem + beaker height + some margin (20px)
            }

            beakerDiv.style.left = `${initialLeft}px`;
            beakerDiv.style.bottom = initialBottom;
            beakerDiv.style.top = ''; // Ensure top is not set if using bottom

            const beakerLabel = document.createElement('span');
            beakerLabel.className = 'beaker-label';
            beakerLabel.textContent = config.label;

            beakerDiv.appendChild(beakerLabel);
            gameContainer.appendChild(beakerDiv); // Append directly to gameContainer
            beakers.push(beakerDiv);

            // Add drag functionality
            addDragListeners(beakerDiv);
        });
    }

    function addDragListeners(element) {
        let isDragging = false;
        let startX, startY;
        let initialLeft, initialTop; // Store initial top position

        element.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY; // Get initial Y for vertical drag
            initialLeft = element.offsetLeft;
            initialTop = element.offsetTop; // Get initial top for vertical drag
            element.style.cursor = 'grabbing';
        });

        element.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY; // Calculate vertical displacement

            let newLeft = initialLeft + dx;
            let newTop = initialTop + dy; // Calculate new top position

            // Constrain beaker movement within gameContainer horizontally
            newLeft = Math.max(0, newLeft);
            newLeft = Math.min(newLeft, gameContainer.clientWidth - element.offsetWidth);

            // Constrain beaker movement within gameContainer vertically
            newTop = Math.max(0, newTop);
            newTop = Math.min(newTop, gameContainer.clientHeight - element.offsetHeight);


            element.style.left = `${newLeft}px`;
            element.style.top = `${newTop}px`; // Apply new top position
        });

        element.addEventListener('mouseup', () => {
            isDragging = false;
            element.style.cursor = 'grab';
        });

        element.addEventListener('mouseleave', () => {
            // If mouse leaves while dragging, stop dragging
            if (isDragging) {
                isDragging = false;
                element.style.cursor = 'grab';
            }
        });

        // Touch events for mobile
        element.addEventListener('touchstart', (e) => {
            isDragging = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY; // Get initial Y for vertical drag
            initialLeft = element.offsetLeft;
            initialTop = element.offsetTop; // Get initial top for vertical drag
            e.preventDefault(); // Prevent scrolling
        });

        element.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY; // Calculate vertical displacement

            let newLeft = initialLeft + dx;
            let newTop = initialTop + dy; // Calculate new top position

            newLeft = Math.max(0, newLeft);
            newLeft = Math.min(newLeft, gameContainer.clientWidth - element.offsetWidth);

            newTop = Math.max(0, newTop);
            newTop = Math.min(newTop, gameContainer.clientHeight - element.offsetHeight);

            element.style.left = `${newLeft}px`;
            element.style.top = `${newTop}px`; // Apply new top position
            e.preventDefault(); // Prevent scrolling
        });

        element.addEventListener('touchend', () => {
            isDragging = false;
        });
    }

    function startGame() {
        instructionsOverlay.style.display = 'none';
        gameRunning = true;
        gameLoop(0); // Start the animation loop
        startTimer(); // Start the game timer
    }

    function endGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId); // Stop the animation loop
        clearInterval(timerIntervalId); // Stop the timer

        finalScoreSpan.textContent = score;
        let percentageScore = 0;
        if (totalIonsSpawned > 0) {
            percentageScore = (score / totalIonsSpawned) * 100;
        }
        percentageScoreSpan.textContent = `${percentageScore.toFixed(0)}%`;

        // Performance comments and confetti
        if (percentageScore >= 70) {
            performanceCommentP.textContent = "🥳 Outstanding! You're a true master of ion colours! 🎉";
            startConfetti();
        } else if (percentageScore >= 50) {
            performanceCommentP.textContent = "👍 Great job! You have a strong understanding of ion colours.";
        } else {
            performanceCommentP.textContent = "😔 Don't worry, practice makes perfect! Review the table and try again! 💪";
        }

        gameOverOverlay.style.display = 'flex';
    }

    // Timer functions
    function startTimer() {
        timerIntervalId = setInterval(() => {
            timeLeft--;
            timerValueSpan.textContent = `${timeLeft}s`;
            if (timeLeft <= 0) {
                endGame();
            }
        }, 1000);
    }

    // Populates the table in the instructions overlay
    function populateInstructionsTable() {
        instructionsIonsTableBody.innerHTML = '';
        aqueousIons.forEach(ion => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${ion.name}</td>
                <td>${ion.commonName}</td>
                <td style="color: ${getDisplayColor(ion.color)}; font-weight: bold;">${ion.color.charAt(0).toUpperCase() + ion.color.slice(1)}</td>
            `;
            instructionsIonsTableBody.appendChild(row);
        });
    }

    // Helper to get a visually distinct color for "yellow/brown" and "pale green" in the table
    function getDisplayColor(colorName) {
        switch(colorName) {
            case 'yellow/brown': return '#DAA520'; // Goldenrod
            case 'pale green': return '#3CB371'; // Medium Sea Green
            case 'colourless': return '#808080'; // Grey for "colourless"
            default: return colorName;
        }
    }

    // --- Game Loop and Logic ---

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        // Create new ion
        if (currentTime - lastIonTime > ionInterval) {
            createIon();
            lastIonTime = currentTime;
        }

        // Move and check collisions for existing ions
        const ions = document.querySelectorAll('.ion');
        ions.forEach(ion => {
            let top = parseFloat(ion.style.top) || 0;
            top += gameSpeed;
            ion.style.top = `${top}px`;

            // Check if ion is out of bounds (falls completely past the bottom of the game container)
            if (top > gameContainer.clientHeight + ion.offsetHeight) {
                ion.remove();
                handleMissedIon();
            } else {
                // Check for collision with beakers
                checkCollision(ion);
            }
        });

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function createIon() {
        let ionData;
        if (Math.random() < colouredIonProbability) {
            // Pick a coloured ion
            const randomIndex = Math.floor(Math.random() * colouredIons.length);
            ionData = colouredIons[randomIndex];
        } else {
            // Pick a colourless ion
            const randomIndex = Math.floor(Math.random() * colourlessIons.length);
            ionData = colourlessIons[randomIndex];
        }

        const ionDiv = document.createElement('div');
        ionDiv.className = 'ion';
        ionDiv.textContent = ionData.name;
        ionDiv.setAttribute('data-color', ionData.color);
        ionDiv.setAttribute('data-name', ionData.commonName); // For potential tooltips

        // Define padding from the edges
        const padding = 20; // pixels
        const ionWidthPx = 50; // Approximate ion width for calculation

        // Calculate max and min left positions to keep ion within bounds + padding
        const minLeft = padding;
        const maxLeft = gameContainer.clientWidth - ionWidthPx - padding;

        // Random horizontal position within the allowed range
        ionDiv.style.left = `${minLeft + Math.random() * (maxLeft - minLeft)}px`;
        ionDiv.style.top = '0px'; // Start at the top

        gameContainer.appendChild(ionDiv);
        totalIonsSpawned++; // Increment total ions spawned
    }

    function checkCollision(ion) {
        const ionRect = ion.getBoundingClientRect();
        const gameContainerRect = gameContainer.getBoundingClientRect();

        beakers.forEach(beaker => {
            const beakerRect = beaker.getBoundingClientRect();

            // Adjust beakerRect to be relative to gameContainer for collision calculation
            const beakerRelativeRect = {
                left: beakerRect.left - gameContainerRect.left,
                top: beakerRect.top - gameContainerRect.top,
                right: beakerRect.right - gameContainerRect.left,
                bottom: beakerRect.bottom - gameContainerRect.top,
                width: beakerRect.width,
                height: beakerRect.height
            };

            // Simple AABB collision detection
            // Collision occurs if ion bottom is below beaker top AND ion top is above beaker bottom
            // AND ion right is right of beaker left AND ion left is left of beaker right
            if (ionRect.bottom > beakerRelativeRect.top &&
                ionRect.top < beakerRelativeRect.bottom &&
                ionRect.right > beakerRelativeRect.left &&
                ionRect.left < beakerRelativeRect.right)
            {
                // Collision detected!
                const ionColor = ion.getAttribute('data-color');
                const beakerColor = beaker.getAttribute('data-color');

                if (ionColor === beakerColor) {
                    handleCorrectCatch(ion, beaker);
                } else {
                    handleIncorrectCatch(ion, beaker);
                }
                ion.remove(); // Remove ion after collision
            }
        });
    }

    function handleCorrectCatch(ion, beaker) {
        score++;
        updateScoreLives();
        playCorrectSound(); // Play correct sound
        createFeedbackMessage('Correct!', ion.getBoundingClientRect().left, ion.getBoundingClientRect().top, 'green');
        createFeedbackParticles(beaker, correctFeedbackColor); // Sparkle effect
        increaseDifficulty();
    }

    function handleIncorrectCatch(ion, beaker) {
        lives--;
        updateScoreLives();
        playWrongSound(); // Play wrong sound
        createFeedbackMessage('Wrong!', ion.getBoundingClientRect().left, ion.getBoundingClientRect().top, 'red');
        createFeedbackParticles(beaker, wrongFeedbackColor); // Shatter/splash effect
        if (lives <= 0) {
            endGame();
        }
    }

    function handleMissedIon() {
        lives--;
        updateScoreLives();
        playWrongSound(); // Play wrong sound for missed ions too
        createFeedbackMessage('Missed!', gameContainer.clientWidth / 2, gameContainer.clientHeight / 2, 'orange'); // Central message for missed
        if (lives <= 0) {
            endGame();
        }
    }

    function updateScoreLives() {
        scoreValueSpan.textContent = score;
        livesValueSpan.textContent = lives;
    }

    function increaseDifficulty() {
        // Increase speed every 10 points
        if (score > 0 && score % 10 === 0) {
            gameSpeed += 0.2; // Increase speed
            ionInterval = Math.max(500, ionInterval - 100); // Decrease interval, but not below 500ms
        }
    }

    function clearIons() {
        document.querySelectorAll('.ion').forEach(ion => ion.remove());
    }

    // --- Visual Feedback Effects ---

    function createFeedbackMessage(message, x, y, color) {
        const msgDiv = document.createElement('div');
        msgDiv.className = 'feedback-message';
        msgDiv.textContent = message;
        msgDiv.style.left = `${x - gameContainer.getBoundingClientRect().left}px`;
        msgDiv.style.top = `${y - gameContainer.getBoundingClientRect().top}px`;
        msgDiv.style.color = color;
        gameContainer.appendChild(msgDiv);

        setTimeout(() => {
            msgDiv.remove();
        }, 1000); // Remove after animation
    }

    function createFeedbackParticles(element, color) {
        const rect = element.getBoundingClientRect();
        const gameRect = gameContainer.getBoundingClientRect();

        // Calculate center relative to gameContainer
        const centerX = rect.left + rect.width / 2 - gameRect.left;
        const centerY = rect.top + rect.height / 2 - gameRect.top;

        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'feedback-particle';
            particle.style.backgroundColor = color;
            const size = Math.random() * 10 + 5; // Random size for particles
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${centerX - size / 2}px`;
            particle.style.top = `${centerY - size / 2}px`;

            // Random direction and distance
            const angle = Math.random() * 2 * Math.PI; // Full circle
            const distance = Math.random() * 80 + 40; // Distance from center
            const endX = Math.cos(angle) * distance;
            const endY = Math.sin(angle) * distance;

            particle.style.setProperty('--end-x', `${endX}px`);
            particle.style.setProperty('--end-y', `${endY}px`);

            gameContainer.appendChild(particle);

            // Remove particle after animation
            setTimeout(() => {
                particle.remove();
            }, 600);
        }
    }

    // --- Confetti Effect ---
    function startConfetti() {
        const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722', '#795548', '#607d8b'];
        const numConfetti = 100; // Number of confetti particles

        for (let i = 0; i < numConfetti; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-particle';
            confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            const size = Math.random() * 10 + 5; // 5 to 15px
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;

            // Position confetti randomly across the top of the game container
            confetti.style.left = `${Math.random() * gameContainer.clientWidth}px`;
            confetti.style.top = `${Math.random() * -gameContainer.clientHeight * 0.2}px`; // Start above the screen

            // Random rotation and fall animation
            const duration = Math.random() * 2 + 1.5; // 1.5 to 3.5 seconds
            const delay = Math.random() * 0.5; // 0 to 0.5 seconds delay
            const endY = gameContainer.clientHeight + 50; // Fall slightly below the screen
            const endXOffset = (Math.random() - 0.5) * 200; // Horizontal drift
            const rotation = Math.random() * 720 + 360; // Rotate 360 to 1080 degrees

            confetti.style.animation = `confetti-fall ${duration}s ease-out ${delay}s forwards`;
            confetti.style.setProperty('--confetti-end-y', `${endY}px`);
            confetti.style.setProperty('--confetti-end-x-offset', `${endXOffset}px`);
            confetti.style.setProperty('--confetti-rotation', `${rotation}deg`);

            gameOverOverlay.appendChild(confetti); // Append to game over overlay

            // Remove confetti after animation to clean up DOM
            setTimeout(() => {
                confetti.remove();
            }, (duration + delay) * 1000);
        }
    }


    // --- Event Listeners ---
    startGameButton.addEventListener('click', () => {
        // Initialize audio context on first user interaction
        initializeAudio();
        startGame();
    });
    playAgainButton.addEventListener('click', initializeGame);

    // Initialize the game when the window loads
    window.onload = initializeGame;

    // Handle window resize to adjust beaker positions if needed
    window.addEventListener('resize', () => {
        // Re-position beakers to keep them horizontally centered relative to the new gameContainer width
        // This initial placement logic is only for the *start* of the game.
        // Once dragged, their positions are managed by the drag listeners.
        // So, we only need to re-initialize if the game is not running or if a reset is desired.
        if (!gameRunning) {
            // Recalculate beaker positions on resize
            createBeakers();
        }
    });

</script>
</body>
</html>
