<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Lab: Metal Displacement Lab</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the application */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* gray-100 */
        }

        /* --- Beaker and Simulation Styles --- */
        #simulation-area {
            position: relative;
            height: 250px;
            width: 180px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-top: 50px; /* Gives space for the metal strip when 'above-beaker' */
        }

        #beaker {
            width: 100%;
            height: 200px;
            border: 5px solid #6b7280; /* gray-500 */
            border-top: none;
            border-radius: 0 0 20px 20px;
            position: absolute;
            bottom: 0;
            background-color: #e5e7eb; /* gray-200 */
            overflow: hidden;
            z-index: 10;
        }

        #solution {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80%;
            transition: background-color 1.5s ease-in-out, height 0.5s ease;
            z-index: 20;
        }

        #metal-strip {
            position: absolute;
            left: 50%;
            width: 40px;
            height: 100px;
            border-radius: 5px 5px 0 0;
            border: 2px solid #4b5563; /* gray-600 */
            z-index: 30;
            /* Changed cubic-bezier to ease-in-out to prevent bouncing */
            transition: transform 0.6s ease-in-out, background-color 1.5s ease;
        }

        .above-beaker {
            transform: translate(-50%, -70px);
            top: 0; /* Align to the top of simulation-area padding */
        }

        .in-solution {
             /* Corrected to -50% for true horizontal centering */
             transform: translate(-50%, 0);
             bottom: 0; /* Keep aligned to the bottom of the beaker */
        }

        /* --- Solution Colors --- */
        .solution-CuSO4 { background-color: #3b82f6; } /* blue-500 */
        .solution-FeSO4 { background-color: #a7f3d0; } /* green-200, for pale green */
        .solution-ZnSO4, .solution-MgSO4, .solution-none, .solution-AgNO3 { background-color: #d1d5db; } /* gray-300, colorless */

        /* --- Metal Colors & Coatings --- */
        .metal-Cu { background-color: #f97316; } /* orange-500 */
        .metal-Zn { background-color: #a1a1aa; } /* zinc-400 */
        .metal-Mg { background-color: #e5e7eb; } /* gray-200 */
        .metal-Fe { background-color: #78716c; } /* stone-500 */
        .metal-Ag { background-color: #cbd5e1; } /* slate-300 for silver */
        .coated-Cu { background-color: #f97316 !important; }
        .coated-Zn { background-color: #a1a1aa !important; }
        .coated-Fe { background-color: #78716c !important; }
        .coated-Ag { background-color: #cbd5e1 !important; }


        /* --- Microscopic Animation --- */
        #animation-container {
            height: 200px;
            border: 2px dashed #9ca3af;
            background-color: #fff;
            position: relative;
            overflow: hidden; /* Ensure particles stay within bounds */
        }
        .particle {
            position: absolute;
            width: 50px; /* Increased size */
            height: 50px; /* Increased size */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 1.1rem; /* Increased font size */
            /* Ensure transformations are centered correctly for consistent movement */
            transform: translate(-50%, -50%);
        }

        /* For symbol transformation */
        .particle span.symbol {
            transition: opacity 0.3s ease-in-out;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Centered within particle */
        }
        .particle .atom-symbol { opacity: 1; }
        .particle .ion-symbol { opacity: 0; }
        .particle.is-ion .atom-symbol { opacity: 0; }
        .particle.is-ion .ion-symbol { opacity: 1; }

        /* Specific ion color */
        .particle.is-ion {
            background-color: #3b82f6; /* Blue for ions */
        }

        /* Electron specific styles */
        .particle.electron {
            background-color: #facc15; /* yellow-400 */
            color: #1f2937; /* gray-800 */
            width: 30px; /* Increased size */
            height: 30px; /* Increased size */
            font-size: 0.8rem; /* Increased font size */
            box-shadow: none; /* No shadow for electrons */
            z-index: 50; /* Ensure electrons are on top */
        }


        /* --- Drag and Drop Challenge --- */
        .draggable {
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; /* Added transitions */
            font-size: 0.9rem; /* Reduced font size for draggable metals */
            padding: 0.75rem; /* Adjusted padding to better fit smaller text */
        }
        .draggable:hover {
            transform: scale(1.02); /* Slight scale up on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.25); /* More prominent shadow on hover */
        }
        .draggable:active {
            transform: scale(0.98); /* Slightly shrink on active/click */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); /* Add subtle inner shadow */
        }

        .drop-zone { border: 2px dashed #9ca3af; min-height: 50px; }
        .drop-zone.hovered { background-color: #dbeafe; border-color: #3b82f6; }
        .feedback-correct { color: #16a34a; } /* green-600 */
        .feedback-incorrect { color: #dc2626; } /* red-600 */

        /* Mobile-specific fixes */
        @media (max-width: 767px) {
            /* Adjust simulation area for mobile */
            #simulation-area {
                height: 200px;
                width: 140px;
                margin: 0 auto;
                padding-top: 40px; /* Adjusted padding-top for mobile */
            }

            #beaker {
                height: 160px;
            }

            #metal-strip {
                width: 30px;
                height: 120px; /* Adjusted height for mobile */
            }

            /* Adjust metal strip positioning for mobile */
            .above-beaker {
                transform: translate(-50%, -125px); /* Adjusted for mobile */
            }

            /* Adjust module layouts */
            .simulation-container {
                flex-direction: column;
                gap: 20px;
            }

            #lab-results {
                width: 100%;
                text-align: center;
            }

            /* Challenge module adjustments */
            #challenge-module .grid {
                grid-template-columns: 1fr;
            }

            #drop-zones {
                grid-template-columns: 1fr; /* Stack drop zones vertically on mobile */
                gap: 8px;
            }
            /* Ensure the most reactive/least reactive text aligns with stacked drop zones */
            .reactivity-series-layout {
                flex-direction: column;
            }
            .reactivity-series-layout span {
                margin-bottom: 8px; /* Add space below "Most Reactive" */
                margin-top: 8px; /* Add space above "Least Reactive" */
            }
        }

        /* Tablet adjustments */
        @media (min-width: 768px) and (max-width: 1023px) {
            #simulation-area {
                height: 220px;
                width: 160px;
                padding-top: 45px; /* Adjusted padding-top for tablet */
            }

            #beaker {
                height: 180px;
            }

            #metal-strip {
                height: 135px; /* Adjusted height for tablet */
            }

            .above-beaker {
                transform: translate(-50%, -135px); /* Adjusted for tablet */
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-6 md:p-8">

    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Virtual Lab</h1>
            <p class="text-lg text-gray-600 mt-2">An interactive lab to explore metal displacement reactions.</p>
        </header>

        <main class="space-y-12">
            <!-- MODULE 1: THE REACTIVITY LAB -->
            <section id="lab-module" class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 flex items-center"><span class="text-3xl mr-3">üß™</span>The Reactivity Lab</h2>
                <div class="flex flex-col md:flex-row md:items-start md:space-x-8">
                    <!-- Controls Panel -->
                    <div class="md:w-1/3 lg:w-1/4 mb-6 md:mb-0">
                        <div class="controls-container flex flex-col gap-4">
                            <div class="control-group w-full">
                                <label for="metal-select" class="block text-sm font-medium text-gray-700 mb-1">Choose a Metal:</label>
                                <select id="metal-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    <option value="Zn">Zinc (Zn)</option>
                                    <option value="Cu">Copper (Cu)</option>
                                    <option value="Mg">Magnesium (Mg)</option>
                                    <option value="Fe">Iron (Fe)</option>
                                    <option value="Ag">Silver (Ag)</option>
                                </select>
                            </div>
                            <div class="control-group w-full">
                                <label for="solution-select" class="block text-sm font-medium text-gray-700 mb-1">Choose a Solution:</label>
                                <select id="solution-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    <option value="CuSO4">Copper(II) Sulphate (CuSO‚ÇÑ)</option>
                                    <option value="ZnSO4">Zinc Sulphate (ZnSO‚ÇÑ)</option>
                                    <option value="MgSO4">Magnesium Sulphate (MgSO‚ÇÑ)</option>
                                    <option value="FeSO4">Iron(II) Sulphate (FeSO‚ÇÑ)</option>
                                    <option value="AgNO3">Silver Nitrate (AgNO‚ÇÉ)</option>
                                </select>
                            </div>
                            <button id="mix-button" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105">
                                Dip Metal in Solution
                            </button>
                        </div>
                    </div>

                    <!-- Experimental Set-up Panel -->
                    <div class="flex-1 md:w-2/3 lg:w-3/4">
                        <div class="simulation-container flex flex-col md:flex-row items-center justify-center gap-8 pt-6 md:pt-0 md:border-l md:pl-8 border-gray-200">
                            <div id="simulation-area">
                                <div id="metal-strip" class="above-beaker metal-Zn"></div>
                                <div id="beaker">
                                    <div id="solution" class="solution-CuSO4"></div>
                                </div>
                            </div>
                            <div id="lab-results" class="flex-1 text-center sm:text-left min-w-[250px]">
                                <h3 id="reaction-outcome" class="text-xl font-semibold text-gray-800 transition-all duration-500">Select a metal and solution to begin.</h3>
                                <p id="chemical-equation" class="text-lg text-gray-600 mt-2 font-mono"></p>
                                <!-- Explanation Button -->
                                <button id="explain-reaction-button" class="hidden mt-4 w-full bg-purple-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-transform transform hover:scale-105">
                                    Explain Reaction ‚ú®
                                </button>
                                <div id="explanation-container" class="hidden mt-4 p-4 bg-purple-50 rounded-lg border border-purple-200 text-sm text-gray-800">
                                    <p id="explanation-text" class="mb-2"></p>
                                    <button id="close-explanation-button" class="bg-purple-200 text-purple-800 text-xs font-semibold py-1 px-3 rounded-md hover:bg-purple-300">
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- MODULE 2: THE MICROSCOPIC VIEW -->
            <section id="microscopic-module" class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 flex items-center"><span class="text-3xl mr-3">üî¨</span>The Microscopic View</h2>
                <div id="microscopic-content" class="hidden">
                    <p class="mb-4 text-gray-600">Here's the electron transfer that drives the reaction. Atoms from the more reactive metal are oxidized (lose electrons), while ions of the less reactive metal are reduced (gain electrons).</p>
                    <div class="flex flex-col md:flex-row gap-6 items-center">
                        <div id="animation-container" class="rounded-lg relative w-full md:w-1/2 min-h-[200px] border border-gray-300 bg-gray-50 flex items-center justify-center">
                            <p class="text-gray-400">Animation will play here</p>
                        </div>
                        <div id="half-equations" class="space-y-4 w-full md:w-1/2">
                            <p id="oxidation-half-equation" class="text-lg font-mono p-3 bg-red-50 text-red-700 border-l-4 border-red-500 rounded"></p>
                            <p id="reduction-half-equation" class="text-lg font-mono p-3 bg-green-50 text-green-700 border-l-4 border-green-500 rounded"></p>
                            <button id="toggle-animation-button" class="w-full bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-transform transform hover:scale-105">
                                Stop Animation
                            </button>
                        </div>
                    </div>
                </div>
                <p id="microscopic-placeholder" class="text-gray-500">A microscopic view will appear here when a reaction occurs.</p>
            </section>

            <!-- MODULE 3: THE REACTIVITY CHALLENGE -->
            <section id="challenge-module" class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 flex items-center"><span class="text-3xl mr-3">üèÜ</span>The Reactivity Challenge</h2>
                <p class="mb-6 text-gray-600">Experiment with three unknown metals (A, B, C) to determine their reactivity series. Click 'Test' to see the result, then drag them into the correct order.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-lg font-semibold mb-2">Results Log</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full border border-gray-300 text-center">
                                <thead class="bg-gray-100">
                                    <tr>
                                        <th class="p-3 border">Metal / Solution</th>
                                        <th class="p-3 border">Solution A</th>
                                        <th class="p-3 border">Solution B</th>
                                        <th class="p-3 border">Solution C</th>
                                    </tr>
                                </thead>
                                <tbody id="results-table-body"></tbody>
                            </table>
                        </div>
                        <div class="mt-4 p-3 bg-gray-50 rounded-lg text-sm text-gray-700">
                            <h4 class="font-semibold mb-1">Key:</h4>
                            <p><span class="text-green-600 font-bold text-lg mr-2">‚úî</span> Reaction Occurs</p>
                            <p><span class="text-red-600 font-bold text-lg mr-2">‚ùå</span> No Reaction</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-2">Build the Reactivity Series</h3>
                        <div class="reactivity-series-layout flex items-center justify-between gap-2 sm:gap-4 p-4 bg-gray-50 rounded-lg">
                            <span class="font-medium text-red-600 mb-2 sm:mb-0">Most Reactive</span>
                            <div id="drop-zones" class="w-full grid grid-cols-1 sm:grid-cols-3 gap-2 flex-1"></div>
                            <span class="font-medium text-blue-600 mt-2 sm:mt-0">Least Reactive</span>
                        </div>
                        <div id="metal-pool" class="mt-4 flex justify-center gap-4 p-4 bg-gray-50 rounded-lg"></div>
                        <div class="flex flex-col sm:flex-row gap-3 mt-4">
                            <button id="check-challenge-button" class="flex-1 bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-transform transform hover:scale-105">
                                Check My Answer
                            </button>
                            <button id="reset-challenge-button" class="flex-1 bg-gray-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform transform hover:scale-105">
                                Reset
                            </button>
                        </div>
                        <p id="challenge-feedback" class="mt-3 text-center font-semibold text-lg h-6"></p>

                        <!-- Challenge Explanation Container -->
                        <div id="challenge-explanation-container" class="hidden mt-4 p-4 bg-lime-50 rounded-lg border border-lime-200 text-sm text-gray-800">
                            <h4 class="font-semibold mb-2">Challenge Feedback:</h4>
                            <p id="challenge-explanation-text" class="mb-2"></p>
                            <button id="close-challenge-explanation-button" class="bg-lime-200 text-lime-800 text-xs font-semibold py-1 px-3 rounded-md hover:bg-lime-300">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Updated metalInfo and solutionInfo to include cationCharge and anion details
            const reactivity = { 'Mg': 4, 'Zn': 3, 'Fe': 2, 'Cu': 1, 'Ag': 0 }; // Added Silver with reactivity 0
            const metalInfo = {
                'Cu': { name: 'Copper', symbol: 'Cu', ion: 'Cu¬≤‚Å∫', color: 'bg-orange-500', cationCharge: 2 },
                'Zn': { name: 'Zinc', symbol: 'Zn', ion: 'Zn¬≤‚Å∫', color: 'bg-zinc-400', cationCharge: 2 },
                'Mg': { name: 'Magnesium', symbol: 'Mg', ion: 'Mg¬≤‚Å∫', color: 'bg-gray-200', cationCharge: 2 },
                'Fe': { name: 'Iron', symbol: 'Fe', ion: 'Fe¬≤‚Å∫', color: 'bg-stone-500', cationCharge: 2 },
                'Ag': { name: 'Silver', symbol: 'Ag', ion: 'Ag‚Å∫', color: 'bg-slate-300', cationCharge: 1 }
            };
            const solutionInfo = {
                'CuSO4': { name: 'Copper(II) Sulphate', metal: 'Cu', formula: 'CuSO‚ÇÑ', anion: 'SO‚ÇÑ', anionCharge: 2 },
                'ZnSO4': { name: 'Zinc Sulphate', metal: 'Zn', formula: 'ZnSO‚ÇÑ', anion: 'SO‚ÇÑ', anionCharge: 2 },
                'MgSO4': { name: 'Magnesium Sulphate', metal: 'Mg', formula: 'MgSO‚ÇÑ', anion: 'SO‚ÇÑ', anionCharge: 2 },
                'FeSO4': { name: 'Iron(II) Sulphate', metal: 'Fe', formula: 'FeSO‚ÇÑ', anion: 'SO‚ÇÑ', anionCharge: 2 },
                'AgNO3': { name: 'Silver Nitrate', metal: 'Ag', formula: 'AgNO‚ÇÉ', anion: 'NO‚ÇÉ', anionCharge: 1 }
            };

            const metalSelect = document.getElementById('metal-select');
            const solutionSelect = document.getElementById('solution-select');
            const mixButton = document.getElementById('mix-button');
            const beakerSolution = document.getElementById('solution');
            const metalStrip = document.getElementById('metal-strip');
            const reactionOutcome = document.getElementById('reaction-outcome');
            const chemicalEquation = document.getElementById('chemical-equation');

            const microscopicContent = document.getElementById('microscopic-content');
            const microscopicPlaceholder = document.getElementById('microscopic-placeholder');
            const animationContainer = document.getElementById('animation-container');
            const oxidationEq = document.getElementById('oxidation-half-equation');
            const reductionEq = document.getElementById('reduction-half-equation');
            const toggleAnimationButton = document.getElementById('toggle-animation-button');
            const resetChallengeButton = document.getElementById('reset-challenge-button');

            // Explanation elements (now local)
            const explainReactionButton = document.getElementById('explain-reaction-button');
            const explanationContainer = document.getElementById('explanation-container');
            const explanationText = document.getElementById('explanation-text');
            const closeExplanationButton = document.getElementById('close-explanation-button');

            // Challenge explanation elements (now local)
            const challengeExplanationContainer = document.getElementById('challenge-explanation-container');
            const challengeExplanationText = document.getElementById('challenge-explanation-text');
            const closeChallengeExplanationButton = document.getElementById('close-challenge-explanation-button');


            let animationTimeouts = [];
            let currentOxidizedMetal = null;
            let currentReducedMetal = null;

            // Global variables for touch drag
            let currentDraggedItem = null;
            let initialX, initialY, offsetX, offsetY;

            // Helper to get hex color from Tailwind class for background-color styling
            function getHexColorFromTailwind(tailwindClass) {
                switch (tailwindClass) {
                    case 'bg-orange-500': return '#f97316';
                    case 'bg-zinc-400': return '#a1a1aa';
                    case 'bg-gray-200': return '#e5e7eb';
                    case 'bg-stone-500': return '#78716c';
                    case 'bg-slate-300': return '#cbd5e1'; // Added for silver
                    case 'bg-blue-500': return '#3b82f6';
                    default: return '#cccccc';
                }
            }

            function resetSimulation() {
                reactionOutcome.textContent = 'Select a metal and solution to begin.';
                reactionOutcome.className = 'text-xl font-semibold text-gray-800 transition-all duration-500';
                chemicalEquation.textContent = '';
                mixButton.disabled = false;

                const currentSolutionKey = solutionSelect.value;
                beakerSolution.className = `solution-${currentSolutionKey}`;

                const currentMetal = metalSelect.value;
                metalStrip.className = 'absolute left-1/2 w-[40px] h-[100px] rounded-t-md border-2 border-gray-600';
                metalStrip.classList.add('above-beaker', `metal-${currentMetal}`);

                microscopicContent.classList.add('hidden');
                microscopicPlaceholder.classList.remove('hidden');

                stopAnimation();
                toggleAnimationButton.textContent = "Start Animation";
                animationContainer.innerHTML = '<p class="text-gray-400">Animation will play here</p>';

                // Hide explanation elements on reset
                explainReactionButton.classList.add('hidden');
                explanationContainer.classList.add('hidden');
                explanationText.textContent = '';
            }

            metalSelect.addEventListener('change', resetSimulation);
            solutionSelect.addEventListener('change', resetSimulation);

            mixButton.addEventListener('click', () => {
                mixButton.disabled = true;
                metalStrip.classList.remove('above-beaker');
                metalStrip.classList.add('in-solution');

                // Hide previous explanation when a new mix starts
                explanationContainer.classList.add('hidden');
                explanationText.textContent = '';
                explainReactionButton.classList.add('hidden'); // Hide explain button until simulation completes

                setTimeout(() => {
                    const selectedMetalSymbol = metalSelect.value;
                    const selectedSolutionKey = solutionSelect.value;
                    const solutionMetalSymbol = solutionInfo[selectedSolutionKey].metal;

                    if (reactivity[selectedMetalSymbol] > reactivity[solutionMetalSymbol]) {
                        handleReaction(selectedMetalSymbol, solutionMetalSymbol);
                    } else {
                        handleNoReaction(selectedMetalSymbol, solutionMetalSymbol);
                    }
                    // Show the explanation button after simulation completes
                    explainReactionButton.classList.remove('hidden');
                }, 700);
            });

            function handleReaction(metalIn, metalOut) {
                reactionOutcome.textContent = '‚úÖ Reaction Occurs!';
                reactionOutcome.className = 'text-xl font-semibold text-green-600 transition-all duration-500';

                const metalInInfo = metalInfo[metalIn]; // e.g., Zn
                const metalOutInfo = metalInfo[metalOut]; // e.g., Ag
                const solutionOutDetails = solutionInfo[solutionSelect.value]; // Details of the original solution

                let metalInCoeff = '';
                let solutionOutCoeff = '';
                let solutionInCoeff = '';
                let metalOutCoeff = '';

                // Determine coefficients for balancing based on charges
                // Case: MetalIn is 2+ (e.g., Zn) and MetalOut is 1+ (Ag)
                if (metalInInfo.cationCharge === 2 && metalOutInfo.cationCharge === 1) {
                    solutionOutCoeff = '2'; // Need 2 of solutionOut (e.g., 2AgNO3)
                    metalOutCoeff = '2';    // Produce 2 of metalOut (e.g., 2Ag)
                }

                // Construct the new solution formula based on metalIn and the *original solution's anion*
                let newAnionSymbol = solutionOutDetails.anion;
                let newAnionCharge = solutionOutDetails.anionCharge;
                
                let solutionInFormula = '';
                if (metalInInfo.cationCharge === newAnionCharge) { // e.g., Zn2+ with SO4(2-) or Ag+ with NO3-
                    solutionInFormula = `${metalInInfo.symbol}${newAnionSymbol}`;
                } else if (metalInInfo.cationCharge === 2 && newAnionCharge === 1) { // e.g., Zn2+ with NO3-
                    solutionInFormula = `${metalInInfo.symbol}(${newAnionSymbol})‚ÇÇ`;
                } else if (metalInInfo.cationCharge === 1 && newAnionCharge === 2) { // e.g., Ag+ with SO4 2-
                    solutionInFormula = `${metalInInfo.symbol}‚ÇÇ${newAnionSymbol}`;
                } else { // Fallback, though ideally all cases should be covered
                    solutionInFormula = `${metalInInfo.symbol}(UnknownAnion)`;
                }

                chemicalEquation.innerHTML = `${metalInCoeff}${metalInInfo.symbol}(s) + ${solutionOutCoeff}${solutionOutDetails.formula}(aq) ‚Üí ${solutionInCoeff}${solutionInFormula}(aq) + ${metalOutCoeff}${metalOutInfo.symbol}(s)`;

                setTimeout(() => {
                    beakerSolution.className = 'solution-none';
                    metalStrip.classList.add(`coated-${metalOut}`);
                }, 100);

                currentOxidizedMetal = metalIn;
                currentReducedMetal = metalOut;

                startAnimation();
            }

            function handleNoReaction(metalIn, metalOut) {
                reactionOutcome.textContent = '‚ùå No Reaction.';
                reactionOutcome.className = 'text-xl font-semibold text-red-600 transition-all duration-500';

                const reason = reactivity[metalIn] === reactivity[metalOut]
                    ? `${metalInfo[metalIn].name} cannot displace itself.`
                    : `${metalInfo[metalIn].name} is less reactive than ${metalInfo[metalOut].name}.`;
                chemicalEquation.textContent = reason;

                microscopicContent.classList.add('hidden');
                microscopicPlaceholder.classList.remove('hidden');

                stopAnimation();
                toggleAnimationButton.textContent = "Start Animation";
                animationContainer.innerHTML = '<p class="text-gray-400">Animation will play here</p>';
                currentOxidizedMetal = null;
                currentReducedMetal = null;
            }

            function startAnimation() {
                stopAnimation();
                if (!currentOxidizedMetal || !currentReducedMetal) {
                    return;
                }
                showMicroscopicView(currentOxidizedMetal, currentReducedMetal);
                toggleAnimationButton.textContent = "Stop Animation";
            }

            function stopAnimation() {
                animationTimeouts.forEach(clearTimeout);
                animationTimeouts = [];

                const particles = animationContainer.querySelectorAll('.particle');
                particles.forEach(p => p.remove());

                animationContainer.innerHTML = '<p class="text-gray-400">Animation stopped.</p>';
                toggleAnimationButton.textContent = "Start Animation";
            }

            toggleAnimationButton.addEventListener('click', () => {
                if (toggleAnimationButton.textContent === "Stop Animation") {
                    stopAnimation();
                } else if (currentOxidizedMetal && currentReducedMetal) {
                    startAnimation();
                }
            });

            function showMicroscopicView(metalOxidized, metalReduced) {
                microscopicPlaceholder.classList.add('hidden');
                microscopicContent.classList.remove('hidden');

                const oxInfo = metalInfo[metalOxidized];
                const redInfo = metalInfo[metalReduced];

                // Half-equations using <sup> for charges
                oxidationEq.innerHTML = `<strong>Oxidation:</strong> ${oxInfo.symbol}(s) &rarr; ${oxInfo.symbol}<sup>${oxInfo.cationCharge === 2 ? '2+' : ''}${oxInfo.cationCharge === 1 ? '+' : ''}</sup>(aq) + ${oxInfo.cationCharge}e<sup>-</sup>`;
                reductionEq.innerHTML = `<strong>Reduction:</strong> ${redInfo.symbol}<sup>${redInfo.cationCharge === 2 ? '2+' : ''}${redInfo.cationCharge === 1 ? '+' : ''}</sup>(aq) + ${redInfo.cationCharge}e<sup>-</sup> &rarr; ${redInfo.symbol}(s)`;

                animationContainer.innerHTML = '';

                // Original positions for particles (these are relative to animation-container)
                const oxOriginalTop = '70%';
                const oxOriginalLeft = '20%';
                
                // Collision point
                const collisionTop = '40%';
                const oxCollisionLeft = '45%';
                const redCollisionLeftCenter = '55%'; // Center point for reducing ions

                // 1. Create Oxidizing Particle
                const oxidizingParticle = document.createElement('div');
                oxidizingParticle.className = `particle ${oxInfo.color}`;
                // Update innerHTML to use <sup> for ion symbol
                oxidizingParticle.innerHTML = `<span class="symbol atom-symbol">${oxInfo.symbol}</span><span class="symbol ion-symbol">${oxInfo.symbol}<sup>${oxInfo.cationCharge === 2 ? '2+' : ''}${oxInfo.cationCharge === 1 ? '+' : ''}</sup></span>`;
                oxidizingParticle.style.top = oxOriginalTop;
                oxidizingParticle.style.left = oxOriginalLeft;
                oxidizingParticle.style.transition = 'all 1.5s ease-out';
                animationContainer.appendChild(oxidizingParticle);

                // 2. Create Reducing Particles (handle multiple if Ag is reduced by 2+ metal)
                const numElectronsTransferred = oxInfo.cationCharge; // e.g., Zn loses 2 electrons
                const electronsNeededPerIon = redInfo.cationCharge; // e.g., Ag+ needs 1 electron
                const numReducingParticles = numElectronsTransferred / electronsNeededPerIon; // e.g., 2/1 = 2 Ag+ ions

                const reducingParticles = [];
                const initialRedOffset = 25; // Offset from center for initial distribution
                for (let i = 0; i < numReducingParticles; i++) {
                    const rP = document.createElement('div');
                    rP.className = `particle`;
                    // Update innerHTML to use <sup> for ion symbol
                    rP.innerHTML = `<span class="symbol atom-symbol">${redInfo.symbol}</span><span class="symbol ion-symbol">${redInfo.symbol}<sup>${redInfo.cationCharge === 2 ? '2+' : ''}${redInfo.cationCharge === 1 ? '+' : ''}</sup></span>`;
                    rP.classList.add('is-ion');
                    
                    if (numReducingParticles === 1) {
                        rP.style.top = '10%'; // Standard single position
                        rP.style.left = '80%';
                    } else if (numReducingParticles === 2) {
                        // Position two particles distinctly
                        rP.style.top = '10%';
                        rP.style.left = `calc(80% + ${(i === 0 ? -initialRedOffset : initialRedOffset)}px)`;
                    } else { // Handle more if necessary, or just a generic spread
                        rP.style.top = `${10 + i * 20}%`;
                        rP.style.left = '80%';
                    }
                    rP.style.transition = 'all 1.5s ease-out';
                    animationContainer.appendChild(rP);
                    reducingParticles.push(rP);
                }

                // 3. Create Electrons
                const electrons = [];
                for (let i = 0; i < numElectronsTransferred; i++) {
                    const electronEl = document.createElement('div');
                    electronEl.className = `particle electron`;
                    electronEl.innerHTML = 'e<sup>-</sup>'; // Use <sup> for electron charge
                    electronEl.style.top = collisionTop;
                    electronEl.style.left = oxCollisionLeft; /* Start near the oxidizing atom */
                    electronEl.style.opacity = '0';
                    animationContainer.appendChild(electronEl);
                    electrons.push(electronEl);
                }

                // Phase 1: Particles approach collision point (0s - 1.5s)
                animationTimeouts.push(setTimeout(() => {
                    oxidizingParticle.style.top = collisionTop;
                    oxidizingParticle.style.left = oxCollisionLeft;
                    
                    const collisionRedOffset = 25; // Offset from center for two reducing ions at collision
                    reducingParticles.forEach((rp, index) => {
                         if (numReducingParticles === 2) {
                            rp.style.left = `calc(${redCollisionLeftCenter} + ${(index === 0 ? -collisionRedOffset : collisionRedOffset)}px)`;
                         } else { // Single particle or other cases
                            rp.style.left = redCollisionLeftCenter;
                         }
                         rp.style.top = collisionTop;
                    });

                }, 50));

                // Phase 2: Freeze and Electrons move (1.5s - 3.5s)
                animationTimeouts.push(setTimeout(() => {
                    // Freeze main particles
                    oxidizingParticle.style.transition = 'none';
                    reducingParticles.forEach(rp => rp.style.transition = 'none');

                    // Set electrons to be visible and move them slowly
                    electrons.forEach((el, index) => {
                        animationTimeouts.push(setTimeout(() => {
                            el.style.opacity = '1';
                            el.style.transition = 'all 2s linear'; /* Slower transition for electron transfer */
                            // Aim electrons at distinct reducing particles if multiple
                            if (numReducingParticles === 2) {
                                const targetRedOffset = (index === 0) ? -25 : 25; // Match with collisionRedOffset
                                el.style.left = `calc(${redCollisionLeftCenter} + ${targetRedOffset}px)`;
                            } else {
                                el.style.left = redCollisionLeftCenter;
                            }
                        }, index * 200)); // Stagger electron movement
                    });
                }, 1550));

                // Phase 3: Transformation (3.5s)
                animationTimeouts.push(setTimeout(() => {
                    // Electrons disappear immediately after transfer
                    electrons.forEach(el => { el.style.opacity = '0'; });

                    // Oxidizing particle (atom -> ion)
                    oxidizingParticle.classList.add('is-ion');
                    oxidizingParticle.classList.remove(oxInfo.color);
                    oxidizingParticle.style.backgroundColor = getHexColorFromTailwind('bg-blue-500');

                    // Reducing particles (ion -> atom)
                    reducingParticles.forEach(rp => {
                        rp.classList.remove('is-ion');
                        rp.style.backgroundColor = getHexColorFromTailwind(redInfo.color);
                    });

                }, 3550)); // After 1.5s (approach) + 2s (electron transfer) = 3.5s

                // Phase 4: Hold for 3s (3.5s - 6.5s)
                animationTimeouts.push(setTimeout(() => {
                    // This block is empty, creating the hold
                }, 6550));

                // Phase 5: Final Movement to original positions (starts at 6.5s, ends at 8s)
                animationTimeouts.push(setTimeout(() => {
                    // Re-enable transitions for main particles
                    oxidizingParticle.style.transition = 'all 1.5s ease-out';
                    reducingParticles.forEach(rp => rp.style.transition = 'all 1.5s ease-out');

                    // Move to original starting positions
                    reducingParticles.forEach((rp, index) => {
                        if (numReducingParticles === 1) {
                            rp.style.top = '10%'; // Standard single position
                            rp.style.left = '80%';
                        } else if (numReducingParticles === 2) {
                            rp.style.top = '10%';
                            rp.style.left = `calc(80% + ${(index === 0 ? -initialRedOffset : initialRedOffset)}px)`;
                        } else {
                            rp.style.top = `${10 + index * 20}%`;
                            rp.style.left = '80%';
                        }
                    });
                    
                    oxidizingParticle.style.top = oxOriginalTop;
                    oxidizingParticle.style.left = oxOriginalLeft;

                }, 6550)); // Starts after 3s hold, so 3550ms + 3000ms = 6550ms
            }

            // --- MODULE 3: REACTIVITY CHALLENGE LOGIC ---
            let challengeMetals = [];
            let challengeReactivity = {};
            // let draggedItem = null; // Renamed to currentDraggedItem to avoid conflict
            
            function setupChallenge() {
                const metals = ['A', 'B', 'C'];
                // Assign unique random reactivity values (1, 2, 3 or 4 for each, ensuring no duplicates)
                const availableReactivity = [1, 2, 3, 4]; // Example range of reactivity values
                const assignedReactivity = new Set();
                challengeReactivity = {};
                
                // Shuffle availableReactivity to pick unique values for A, B, C
                for (let i = availableReactivity.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableReactivity[i], availableReactivity[j]] = [availableReactivity[j], availableReactivity[i]];
                }

                metals.forEach(metal => {
                    // Pop a unique reactivity value from the shuffled array
                    challengeReactivity[metal] = availableReactivity.pop();
                });

                // Sort the challenge metals by their assigned reactivity (highest first)
                challengeMetals = Object.keys(challengeReactivity).sort((a, b) => challengeReactivity[b] - challengeReactivity[a]);

                const tableBody = document.getElementById('results-table-body');
                const metalPool = document.getElementById('metal-pool');
                const dropZonesContainer = document.getElementById('drop-zones');
                tableBody.innerHTML = ''; // Clear existing rows
                metalPool.innerHTML = ''; // Clear existing metals in pool
                dropZonesContainer.innerHTML = ''; // Clear existing drop zones
                document.getElementById('challenge-feedback').textContent = ''; // Clear feedback
                challengeExplanationContainer.classList.add('hidden'); // Hide explanation on reset
                challengeExplanationText.textContent = ''; // Clear explanation text on reset


                // Add header row back after clearing body
                const headerRow = `
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="p-3 border">Metal / Solution</th>
                            <th class="p-3 border">Solution A</th>
                            <th class="p-3 border">Solution B</th>
                            <th class="p-3 border">Solution C</th>
                        </tr>
                    </thead>
                `;
                // Check if thead already exists to prevent duplication
                if (!tableBody.previousElementSibling || tableBody.previousElementSibling.tagName !== 'THEAD') {
                    tableBody.insertAdjacentHTML('beforebegin', headerRow);
                } else {
                    // If thead exists, just update its content if necessary
                    tableBody.previousElementSibling.innerHTML = headerRow;
                }
                

                metals.forEach(metal => {
                    const draggable = document.createElement('div');
                    draggable.id = `metal-${metal.toLowerCase()}`;
                    draggable.className = 'draggable bg-gray-500 text-white font-bold p-4 rounded-lg shadow-md';
                    draggable.textContent = `Metal ${metal}`;
                    draggable.draggable = true;
                    metalPool.appendChild(draggable);

                    const dropZone = document.createElement('div');
                    dropZone.className = 'drop-zone p-2 rounded-lg flex items-center justify-center';
                    dropZonesContainer.appendChild(dropZone);

                    const row = document.createElement('tr');
                    let cells = `<th class="p-3 border bg-gray-50">Metal ${metal}</th>`;
                    metals.forEach(solution => {
                        if (metal === solution) {
                            cells += `<td class="p-3 border bg-gray-200">-</td>`;
                        } else {
                            cells += `<td class="p-3 border" data-metal="${metal}" data-solution="${solution}"><button class="test-btn bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-1 px-3 rounded text-sm">Test</button></td>`;
                        }
                    });
                    row.innerHTML = cells;
                    tableBody.appendChild(row);
                });
                addChallengeEventListeners();
                currentDraggedItem = null; // Clear dragged item when challenge is reset
            }

            function addChallengeEventListeners() {
                document.querySelectorAll('.test-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const cell = e.target.parentElement;
                        const metal = cell.dataset.metal;
                        const solution = cell.dataset.solution;
                        cell.innerHTML = challengeReactivity[metal] > challengeReactivity[solution]
                            ? '<span class="text-green-600 font-bold text-2xl">‚úî</span>'
                            : '<span class="text-red-600 font-bold text-2xl">‚ùå</span>';
                    });
                });

                document.querySelectorAll('.draggable').forEach(item => {
                    // Mouse events for desktop
                    item.addEventListener('dragstart', (e) => {
                        currentDraggedItem = e.target;
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', e.target.id);
                        item.style.opacity = '0.4'; 
                    });
                    item.addEventListener('dragend', (e) => {
                        item.style.opacity = '1';
                        currentDraggedItem = null;
                    });

                    // Touch events for mobile
                    item.addEventListener('touchstart', (e) => {
                        currentDraggedItem = e.target;
                        // Create a floating clone for visual feedback
                        const clone = currentDraggedItem.cloneNode(true);
                        clone.id = 'dragging-clone'; // Assign a temporary ID
                        clone.style.position = 'absolute';
                        clone.style.zIndex = '1000';
                        clone.style.width = currentDraggedItem.offsetWidth + 'px';
                        clone.style.height = currentDraggedItem.offsetHeight + 'px';
                        clone.style.pointerEvents = 'none'; // So it doesn't block touch events for elements beneath
                        clone.style.opacity = '0.8';
                        document.body.appendChild(clone);

                        const touch = e.touches[0];
                        initialX = touch.clientX;
                        initialY = touch.clientY;
                        offsetX = touch.clientX - currentDraggedItem.getBoundingClientRect().left;
                        offsetY = touch.clientY - currentDraggedItem.getBoundingClientRect().top;
                        
                        // Set initial position of the clone
                        clone.style.left = (touch.clientX - offsetX) + 'px';
                        clone.style.top = (touch.clientY - offsetY) + 'px';

                        currentDraggedItem.style.visibility = 'hidden'; // Hide the original
                        e.preventDefault(); // Prevent scrolling
                    });

                    item.addEventListener('touchmove', (e) => {
                        if (!currentDraggedItem || !document.getElementById('dragging-clone')) return;
                        const touch = e.touches[0];
                        const clone = document.getElementById('dragging-clone');
                        clone.style.left = (touch.clientX - offsetX) + 'px';
                        clone.style.top = (touch.clientY - offsetY) + 'px';

                        // Simulate dragover feedback for drop zones
                        document.querySelectorAll('.drop-zone').forEach(zone => {
                            zone.classList.remove('hovered');
                        });
                        const elementUnderFinger = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (elementUnderFinger && elementUnderFinger.classList.contains('drop-zone')) {
                            elementUnderFinger.classList.add('hovered');
                        }
                        e.preventDefault(); // Prevent scrolling
                    });

                    item.addEventListener('touchend', (e) => {
                        if (!currentDraggedItem || !document.getElementById('dragging-clone')) return;

                        const clone = document.getElementById('dragging-clone');
                        const touch = e.changedTouches[0];
                        const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);

                        document.querySelectorAll('.drop-zone').forEach(zone => {
                            zone.classList.remove('hovered');
                        });

                        let dropped = false;
                        if (dropTarget && (dropTarget.classList.contains('drop-zone') || dropTarget.id === 'metal-pool')) {
                            let targetZone = dropTarget;
                            // If the actual target is a child of a drop zone (e.g., text inside)
                            while (targetZone && !targetZone.classList.contains('drop-zone') && targetZone.id !== 'metal-pool' && targetZone !== document.body) {
                                targetZone = targetZone.parentElement;
                            }

                            if (targetZone && (targetZone.classList.contains('drop-zone') || targetZone.id === 'metal-pool')) {
                                if (targetZone.children.length === 0 || targetZone.id === 'metal-pool') {
                                    targetZone.appendChild(currentDraggedItem);
                                    currentDraggedItem.style.position = ''; // Reset positioning
                                    currentDraggedItem.style.left = '';
                                    currentDraggedItem.style.top = '';
                                    currentDraggedItem.style.transform = ''; // Clear any transform from drag clone
                                    currentDraggedItem.style.visibility = 'visible'; // Make original visible
                                    dropped = true;
                                } else {
                                    // If target zone is a drop zone and already has a child, swap them
                                    const existingChild = targetZone.children[0];
                                    if (existingChild !== currentDraggedItem) {
                                        const originalParent = currentDraggedItem.parentElement;
                                        targetZone.appendChild(currentDraggedItem);
                                        originalParent.appendChild(existingChild);

                                        currentDraggedItem.style.position = '';
                                        currentDraggedItem.style.left = '';
                                        currentDraggedItem.style.top = '';
                                        currentDraggedItem.style.transform = '';
                                        currentDraggedItem.style.visibility = 'visible';

                                        existingChild.style.position = '';
                                        existingChild.style.left = '';
                                        existingChild.style.top = '';
                                        existingChild.style.transform = '';
                                        existingChild.style.visibility = 'visible';
                                        dropped = true;
                                    }
                                }
                            }
                        }

                        if (!dropped) {
                            // If not dropped on a valid zone, snap back to original pool if it wasn't there
                            const metalPool = document.getElementById('metal-pool');
                            if (!metalPool.contains(currentDraggedItem)) {
                                metalPool.appendChild(currentDraggedItem);
                            }
                            currentDraggedItem.style.position = '';
                            currentDraggedItem.style.left = '';
                            currentDraggedItem.style.top = '';
                            currentDraggedItem.style.transform = '';
                            currentDraggedItem.style.visibility = 'visible';
                        }
                        
                        if (clone) {
                            clone.remove();
                        }
                        currentDraggedItem = null;
                    });
                });

                // Mouse drop events for desktop
                document.querySelectorAll('.drop-zone, #metal-pool').forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); if(e.target.classList.contains('drop-zone') && e.target.id !== 'metal-pool') e.target.classList.add('hovered'); });
                    zone.addEventListener('dragleave', e => { if(e.target.classList.contains('drop-zone') && e.target.id !== 'metal-pool') e.target.classList.remove('hovered'); });
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        const dropZone = e.currentTarget; // The actual drop zone element

                        if (currentDraggedItem) {
                            if (dropZone.children.length === 0 || dropZone.id === 'metal-pool') {
                                dropZone.appendChild(currentDraggedItem);
                            } else {
                                // If dropping on a populated drop-zone, swap elements
                                const existingChild = dropZone.children[0];
                                const originalParent = currentDraggedItem.parentElement;
                                
                                if (existingChild !== currentDraggedItem) { // Prevent dropping onto self
                                    dropZone.appendChild(currentDraggedItem);
                                    originalParent.appendChild(existingChild);
                                }
                            }
                        }
                        if(dropZone.classList.contains('drop-zone') && dropZone.id !== 'metal-pool') dropZone.classList.remove('hovered');
                    });
                });

                document.getElementById('check-challenge-button').addEventListener('click', () => {
                    const dropZones = document.querySelectorAll('#drop-zones .drop-zone');
                    const userAnswer = Array.from(dropZones).map(zone => zone.children.length > 0 ? zone.children[0].textContent.slice(-1) : null);
                    const feedback = document.getElementById('challenge-feedback');
                    const isCorrect = JSON.stringify(userAnswer) === JSON.stringify(challengeMetals);

                    if (isCorrect) {
                        feedback.textContent = 'Correct! Well done!';
                        feedback.className = 'mt-3 text-center font-semibold text-lg h-6 feedback-correct';
                        getChallengeExplanation(true, userAnswer);
                    } else {
                        feedback.textContent = 'Not quite, try again!';
                        feedback.className = 'mt-3 text-center font-semibold text-lg h-6 feedback-incorrect';
                        getChallengeExplanation(false, userAnswer);
                    }
                });
            }

            // --- Local Explanations ---

            // Local explanation for "Explain Reaction" button
            closeExplanationButton.addEventListener('click', () => {
                explanationContainer.classList.add('hidden');
                explanationText.textContent = '';
            });

            explainReactionButton.addEventListener('click', () => {
                explanationContainer.classList.add('hidden');
                explanationText.textContent = '';
                
                const selectedMetalSymbol = metalSelect.value;
                const selectedSolutionKey = solutionSelect.value;
                const solutionMetalSymbol = solutionInfo[selectedSolutionKey].metal;
                const metalInInfo = metalInfo[selectedMetalSymbol];
                const metalOutInfo = metalInfo[solutionMetalSymbol];

                let explanation = '';
                if (reactivity[selectedMetalSymbol] > reactivity[solutionMetalSymbol]) {
                    explanation = `${metalInInfo.name} is more reactive than ${metalOutInfo.name}. Therefore, ${metalInInfo.name} will displace ${metalOutInfo.name} from its solution. This is a redox reaction: ${metalInInfo.name} is oxidized (loses electrons) and ${metalOutInfo.name} ions are reduced (gain electrons) to form solid ${metalOutInfo.name}.`;
                } else if (reactivity[selectedMetalSymbol] < reactivity[solutionMetalSymbol]) {
                    explanation = `${metalInInfo.name} is less reactive than ${metalOutInfo.name}. Therefore, ${metalInInfo.name} cannot displace ${metalOutInfo.name} from its solution. No reaction will occur.`;
                } else { // Same metal
                    explanation = `${metalInInfo.name} is the same metal as the one in the solution. Metals cannot displace themselves. Therefore, no reaction will occur.`;
                }

                explanationText.textContent = explanation;
                explanationContainer.classList.remove('hidden');
            });


            // Local explanation for "Challenge Explanation" after submission
            closeChallengeExplanationButton.addEventListener('click', () => {
                challengeExplanationContainer.classList.add('hidden');
                challengeExplanationText.textContent = '';
            });

            function getChallengeExplanation(isCorrect, userAnswer) {
                challengeExplanationContainer.classList.add('hidden');
                challengeExplanationText.textContent = '';

                let explanation = '';
                if (isCorrect) {
                    explanation = `Excellent! The order ${challengeMetals.join(' > ')} is correct. This represents the reactivity series, where the most reactive metal (left) can displace less reactive metals from their compounds.`;
                } else {
                    const incorrectOrder = userAnswer.filter(item => item !== null).join(' > ');
                    const correctOrder = challengeMetals.join(' > ');
                    explanation = `Not quite. Your order was "${incorrectOrder}". The correct order is "${correctOrder}". Remember, the reactivity series is determined by how easily a metal loses electrons. A more reactive metal will displace a less reactive metal from its compound. Review your test results to see which metals reacted and which did not.`;
                }
                challengeExplanationText.textContent = explanation;
                challengeExplanationContainer.classList.remove('hidden');
            }


            // Event listener for the "Reset" button in the challenge section
            resetChallengeButton.addEventListener('click', setupChallenge);

            // --- INITIALIZATION ---
            resetSimulation();
            setupChallenge();
        });
    </script>
</body>
</html>
